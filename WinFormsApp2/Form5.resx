<root>
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="label1.Text" xml:space="preserve">
    <value>Гномья сортировка не является быстрым алгоритмом для сортировки, время его работы равно O(n^2). Хоть сортировка и является достаточно примитивной она является самой первой сортировкой для освоения групп сортировок называемые сортировкой вставками. Гномья сортировка больше всего подходит для обучающихся программированию, как первый шаг для обучения сортировкам вставками. Чисто технически эта сортировка не используется в крупных программах, так как уже существуют более скоростные сортировки.</value>
  </data>
  <data name="label2.Text" xml:space="preserve">
    <value>Сортировка подсчетом довольна простая, но тем не менее очень эффективная сортировка. Она плохо подходит для сортировки маленьких массивов, так как ей приходиться создавать дополнительный массив для уникальных значений. Единственным минусом этой сортировки является, то, что ее не получиться комбинировать с другими сортировками и такая сортировка может работать только по одному алгоритму. При хорошей постановке алгоритма в коде эта сортировка может стать довольно быстрой, подсчитать все элементы за один проход и заполнить ими новый массив. То есть время работы алгоритма равно O(n + k), n – количество элементов, k – количество уникальных элементов в массиве.</value>
  </data>
  <data name="label3.Text" xml:space="preserve">
    <value>Шейкерная сортировка, как и сортировка гномиков берет за основу алгоритм пузырьковой сортировки. Как отдельная сортировка в крупных программах она почти не используется, чаще всего она используется в комбинации с другими сортировками, к примеру с такими как сортировка слиянием, быстрая сортировка и тд. В отличие от пузырьковой сортировки, она работает как слева направо, так и справа налево. Это уменьшает количество его внешних итераций. Время работы для алгоритма сортировки пузырьком в худшем и среднем случае – O(n2), в лучшем случае – O(n). Время работы у алгоритма шейкерной сортировки такая же, как и у сортировки пузырьком, однако чисто технически реальное время работы намного лучше.</value>
  </data>
</root>